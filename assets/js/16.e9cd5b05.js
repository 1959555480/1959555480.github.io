(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{359:function(t,a,s){"use strict";s.r(a);var e=s(42),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),s("h2",{attrs:{id:"数据请求在-vue-的生命周期的哪个阶段？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据请求在-vue-的生命周期的哪个阶段？"}},[t._v("#")]),t._v(" 数据请求在 vue 的生命周期的哪个阶段？")]),t._v(" "),s("ul",[s("li",[t._v("不考虑服务端渲染的情况下，一般选在 "),s("strong",[t._v("mounted")]),t._v(" 周期内请求数据，因为这个周期开始，当前组件已经被挂载到真实的元素上了。")])]),t._v(" "),s("h2",{attrs:{id:"与-vue3-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与-vue3-区别"}},[t._v("#")]),t._v(" 与 Vue3 区别")]),t._v(" "),s("ul",[s("li",[t._v("Vue2 中使用的 Oject.defineProperty 双向绑定，Vue3 中使用 Proxy 代理")])]),t._v(" "),s("h2",{attrs:{id:"vue组件中data为什么必须是一个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue组件中data为什么必须是一个函数"}},[t._v("#")]),t._v(" Vue组件中data为什么必须是一个函数")]),t._v(" "),s("ul",[s("li",[t._v("对象是引用类型，当复用组件的时候，由于数据对象都指向的同一个data对象，当一个组件修改data的时候，其他复用的组件data也会被修改；而使用返回对象的函数，由于每次返回的都是一个新函数（函数也是Object的实例对象），引用的地址不同，则不会出现这个问题。")])]),t._v(" "),s("h2",{attrs:{id:"v-if和-v-show-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if和-v-show-的区别"}},[t._v("#")]),t._v(" v-if和 v-show 的区别")]),t._v(" "),s("ol",[s("li",[t._v("v-if 在条件切换时，会对标签进行创建和销毁，而v-show则仅在初始化时加载一次，因此v-if开销相对来说比v-show高")]),t._v(" "),s("li",[t._v("v-if是惰性的，只有当条件为真的时候才会真正渲染标签；v-show则无论条件是否成立都会渲染标签，它做得仅仅是简单的css切换")])]),t._v(" "),s("h2",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])])])}),[],!1,null,null,null);a.default=v.exports}}]);